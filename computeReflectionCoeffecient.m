function [X, theta] = computeReflectionCoeffecient(ntheta, params)
% [X, theta] = computeReflectionCoeffecient(ntheta, params)
%
% Computes the reflection or transmission coefficient with the parameters
% specified in the params-struct (see parsAsmInput for more details).
% ntheta specifies how many angle the reflection coefficient should be
% calculated at from params.thetamin to params.thetamax
% 
%
% Input:
% ntheta - Number of angles
% params - Parameters as generated by parseAsmInput
% 
% Output:
% X - Reflection or transmission coefficients. Size: ntheta x num freq
% theta - Angles for which X is computed
%

%% Unpack parameters
aRx = params.aRx;
aTx = params.aTx;
c_F = params.cf;
rho_F = params.rho_fluid;
rho_S = params.rho_solid;
cp = params.cp;
cs = params.cs;
thick = params.thickness;
d1 = params.distanceTx;
d3 = params.distanceRx;
al_dB = params.alphaLambda_dB;
fres = 0.5*params.cp/params.thickness; %#ok<*NASGU>
x0 = params.displaceRx;
refl = params.reflection;


%% Samplings stuff
f = params.f;
nf = length(f);
thetamax = params.thetamax;
thetamin = params.thetamin;
theta = linspace(thetamin, thetamax, ntheta);
q = sin(theta);

X = zeros(ntheta, nf);
for i = 1:nf
    %% Plate response, angular
    % Multiply with wave length and convert from dB to linear
    % Loss parameter
    if al_dB ~= 0
        % log(10)/10 = 0.2303
        alphaL = al_dB*0.2303*f(i)/c_F;
    else
        alphaL = 0;
    end
    
    %% Reflection/Transmission coefficient
    if refl
        Plate = reflectionCoefficientAnalytical(f(i), q,...
            thick, rho_F, rho_S, cp, cs, c_F, alphaL);
    else
        [~, Plate] = reflectionCoefficientAnalytical(f(i), q,...
            thick, rho_F, rho_S, cp, cs, c_F, alphaL);
    end
    
    X(:, i) = Plate;
end

end